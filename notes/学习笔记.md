### let 与 var 区别
+ 产生块级作用域
+ 不会变量声明提升

### const
+ 利用const声明变量，只读，不可被修改
+ 声明对象，可以修改对象中的属性，不可以改变对象的指针

### 带标签模版字符串
+ 带标签的模板字符串，可以自定义函数处理模板字符串

### 字符串的扩展方法
+ str.startsWidth(判断的字符串)  判断当前字符串是否以另一个字符串作为开头
+ str.endsWidth(判断的字符串) 判断当前字符串是否以另一个字符串结尾
+ str.includes(字符串) 判断当前字符串是否包含另一个字符串 

### 参数默认值
+ 用法：没有传值，或者值为undefind时使用 function(b, a = 1)
+ 注意事项：参数默认值需要放到参数最后面

### 剩余参数
+ 用法 fun(...args) args 为数组
+ 注意事项： 只能出现在形参最后一位，而且只能使用一次

### 箭头函数
+ 语法： (n,m) => n+1  使用=>{}需要return 返回值
+ this问题： 箭头函数中所使用的this都是来自函数作用域链，它的取值遵循普通普通变量一样的规则

### 对象字面量
+ 计算属性名  const obj = { [表达式]:1 } 利用中括号 任意表达式 结果为属性名

### Object.assign
+ 作用：将多个源对象中的属性复制到一个目标对象中
 
### Obeject.is
+ 作用：确定两个值是否相同

### Proxy 与 defineProperty 区别
+ Proxy 能够监视到更多对象操作
+ Proxy 更好到对数组对象监视
+ Proxy 是以非侵入方式监管对象读写（不需要对监视对象做任何操作）

### Reflect 
+ 作用：是一个内置的对象，它提供拦截 JavaScript 操作的方法

### Map 数据结构与普通对象区别
+ 一个 Map的键可以是任意值，Object 的键必须是一个 String 或是Symbol
+ Map键是有序的，Object无序
+ Map 可以迭代 Object需要手动封装迭代
+ Map频繁增删值场景表现更好

### Symbol 
+ 特点：唯一，不会重复
+ 为对象添加独一无二标示符
+ 作为对象私有属性

### for of 
+ 获取遍历的值
+ 可以使用break 终止循环
+ 可以遍历伪数组
+ 使用数组结构方法可以遍历Map数据键和值
+ 所有被for of 实现遍历都需要有Symbol.iterator 接口 

### Es2016 概述
+ Array.prototype.includes  判断是否包含某元素 相比indexOf 可以查找NaN
+ 指数运算符 （2 ** 4） 代表2 的 4次方

### Es2017 概述
+ Object.values 返回一个给定对象自身的所有可枚举属性值的数组
+ Object.entries 返回一个给定对象自身可枚举属性的键值对数组（可以使用for of循环）

### 异步模式
+ Event loop 监听调用栈和消息队列
+ 运行环境提供的API是以同步还是异步模式进行工作

### 回调函数
+ 由调用者定义，交给执行者执行的函数

### Promise 
+ Promise对象resolve 和reject如果不穿值的话返回undefind
+ Promise对象的then方法返回一个全新的Promise对象
+ 后面的then方法就是为上一个then返回Promise注册回调
+ 前面then方法中回调函数的返回值会作为后面then回调的参数
+ 如果回调中返回的是Promise,那么后面then方法的回调会等待它的结束 
+ Promise 回调会作为微任务执行

+ Promise捕获异常 ctach 方法（比较通用 ）
+ Promise捕获异常 onRejected 方法 只是给当前 Promise 对象注册的失败回调


### async function 用来定义一个返回 AsyncFunction 对象的异步函数
+ 返回的Promise对象会运行执行(resolve)异步函数的返回结果，或者运行拒绝(reject)——如果异步函数抛出异常的话。
+ 一个async异步函数可以包含await指令，该指令会暂停异步函数的执行，并等待Promise执行，然后继续执行异步函数，并返回结果
+ await返回 Promise 对象的处理结果。如果等待的不是 Promise 对象，则返回该值本身。


### 强类型与弱类型
+ 强类型不允许随意的隐式类型转换
+ 弱类型允许随意隐式类型转换

### 静态类型与动态类型
+ 静态类型：一个变量声明时它的类型就是明确的，声明过后，它的类型不会被修改
+ 动态类型 运行阶段才能明确变量类型，而且可以更改变量

### 强类型的优势
+ 错误更早报漏
+ 代码更只能，编码更正确 
+ 重构更牢靠
+ 减少不必要的类型判断

### flow JavaScript静态类型检查工具
+ 在被检查的文件最顶部添加 @flow 标识的注释对该文件进行检查
+ npm run flow    启动Flow服务(只检查变化部分)
+ fow 执行Flow检查
+ npm run flow stop    停止Flow服务
+ flow-remove-types是用于从文件中剥离流类型注释的小型CLI工具
+ 使用babel编译flow代码
+ Flow support 自动检测代码
+ mixed 为强类型（没有类型隐患） any为弱类型

### typecript
+ tsc 编译ts文件  yarn tsc 文件名.ts
+ 标准库就是内置对象所对应的声明
+ 设置中文错误消息 vscode设置 typescript local 设置
+ typecript 作用域问题 （放在单独作用域使用）
+ typecript objecy类型不是单指对象（除了原始类型以外的类型）
+ 元组类型 元组中允许存储不同类型的元素，元组可以作为参数传递给函数
+ 枚举 使用枚举可以清晰地表达意图或创建一组有区别的用例 数字枚举 字符串枚举  常量枚举
+ 函数类型 定义参数类型 以及返回值类型 可以定义可选参数以及默认参数
+ any 任意类型（弱类型） any类型不安全（轻易不使用）
+ 隐式类型推断：变量声明时不加类型判断，会默认为赋值类型，如果没有值默认为any类型 （建议加上类型判断）
+ 类型断言：使用as关键字（推荐使用）和<type> 类型断言不是类型转换，编译阶段使用编译结束消失
+ 抽象类做为其它派生类的基类使用。 它们一般不会直接被实例化。 不同于接口，抽象类可以包含成员的实现细节。